<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Debug - Microphone Test</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      
      body { 
        font-family: -apple-system, system-ui, sans-serif; 
        background: #000000;
        color: #ffffff;
        user-select: none;
        -webkit-user-select: none;
        height: 100vh;
        overflow: hidden;
      }
      
      .container {
        display: flex;
        flex-direction: column;
        height: 100vh;
        padding: 20px;
        max-width: 800px;
        margin: 0 auto;
      }
      
      .header {
        text-align: center;
        margin-bottom: 30px;
        border-bottom: 1px solid #333;
        padding-bottom: 20px;
      }
      
      .title {
        font-size: 28px;
        font-weight: 600;
        margin-bottom: 10px;
        color: #00ff00;
      }
      
      .subtitle {
        font-size: 14px;
        opacity: 0.7;
        color: #888;
      }
      
      .status {
        font-size: 16px;
        opacity: 0.9;
        margin-bottom: 20px;
        padding: 10px;
        background: #111;
        border-radius: 8px;
        border: 1px solid #333;
      }
      
      .controls {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-bottom: 30px;
        flex-wrap: wrap;
      }
      
      .btn {
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        min-width: 100px;
      }
      
      .btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }
      
      .btn-start {
        background: #00ff00;
        color: #000;
      }
      
      .btn-start:hover:not(:disabled) {
        background: #00cc00;
        transform: translateY(-1px);
      }
      
      .btn-stop {
        background: #ff0000;
        color: #fff;
      }
      
      .btn-stop:hover:not(:disabled) {
        background: #cc0000;
        transform: translateY(-1px);
      }
      
      .btn-play {
        background: #0066ff;
        color: #fff;
      }
      
      .btn-play:hover:not(:disabled) {
        background: #0052cc;
        transform: translateY(-1px);
      }
      
      .btn-convert {
        background: #9900ff;
        color: #fff;
      }
      
      .btn-convert:hover:not(:disabled) {
        background: #7a00cc;
        transform: translateY(-1px);
      }
      
      .btn-send {
        background: #ff6600;
        color: #fff;
      }
      
      .btn-send:hover:not(:disabled) {
        background: #cc5200;
        transform: translateY(-1px);
      }
      
      .btn-copy {
        background: #00ccff;
        color: #000;
      }
      
      .btn-copy:hover:not(:disabled) {
        background: #00a3cc;
        transform: translateY(-1px);
      }
      
      .btn-status {
        background: #00ff00;
        color: #000;
      }
      
      .btn-status:hover:not(:disabled) {
        background: #00cc00;
        transform: translateY(-1px);
      }
      
      .visualization {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 80px;
        margin-bottom: 30px;
        background: #111;
        border-radius: 8px;
        padding: 20px;
        border: 1px solid #333;
      }
      
      .audio-bars {
        display: flex;
        align-items: center;
        gap: 3px;
        height: 40px;
      }
      
      .audio-bar {
        width: 4px;
        background: #00ff00;
        border-radius: 2px;
        transition: height 0.1s ease;
      }
      
      .recording .audio-bar {
        animation: audioWave 0.8s ease-in-out infinite;
      }
      
      .audio-bar:nth-child(1) { animation-delay: 0s; }
      .audio-bar:nth-child(2) { animation-delay: 0.1s; }
      .audio-bar:nth-child(3) { animation-delay: 0.2s; }
      .audio-bar:nth-child(4) { animation-delay: 0.3s; }
      .audio-bar:nth-child(5) { animation-delay: 0.4s; }
      .audio-bar:nth-child(6) { animation-delay: 0.5s; }
      .audio-bar:nth-child(7) { animation-delay: 0.6s; }
      .audio-bar:nth-child(8) { animation-delay: 0.7s; }
      
      @keyframes audioWave {
        0%, 100% { height: 8px; }
        50% { height: 40px; }
      }
      
      .debug-section {
        flex: 1;
        background: #111;
        border-radius: 8px;
        padding: 20px;
        overflow-y: auto;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 12px;
        line-height: 1.4;
        border: 1px solid #333;
      }
      
      .debug-title {
        font-size: 14px;
        font-weight: 600;
        margin-bottom: 15px;
        color: #00ff00;
      }
      
      .debug-log {
        margin-bottom: 8px;
        padding: 8px;
        background: #222;
        border-radius: 4px;
        border-left: 3px solid #00ff00;
      }
      
      .debug-error {
        border-left-color: #ff0000;
        background: #330000;
      }
      
      .debug-warn {
        border-left-color: #ff6600;
        background: #331a00;
      }
      
      .debug-info {
        border-left-color: #0066ff;
        background: #001a33;
      }
      
      .recording-indicator {
        display: inline-block;
        width: 10px;
        height: 10px;
        background: #ff0000;
        border-radius: 50%;
        margin-right: 8px;
        animation: pulse 1.5s ease-in-out infinite;
      }
      
      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
      }
      
      .recording .recording-indicator {
        display: inline-block;
      }
      
      .recording .status {
        color: #ff0000;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <div class="title">
          <span class="recording-indicator" id="recordingIndicator" style="display: none;"></span>
          Debug - Microphone Test
        </div>
        <div class="subtitle">Comprehensive audio recording and transcription testing</div>
      </div>
      
      <div class="status" id="status">Ready to record</div>
      
      <div class="visualization" id="visualization">
        <div class="audio-bars" id="audioBars">
          <div class="audio-bar"></div>
          <div class="audio-bar"></div>
          <div class="audio-bar"></div>
          <div class="audio-bar"></div>
          <div class="audio-bar"></div>
          <div class="audio-bar"></div>
          <div class="audio-bar"></div>
          <div class="audio-bar"></div>
        </div>
      </div>
      
      <div class="controls">
        <button class="btn btn-start" id="startBtn">Start Recording</button>
        <button class="btn btn-stop" id="stopBtn" disabled>Stop Recording</button>
        <button class="btn btn-play" id="playBtn" disabled>Play Recording</button>
        <button class="btn btn-convert" id="convertBtn" disabled>Convert to Base64</button>
        <button class="btn btn-send" id="sendBtn" disabled>Send to Gemini</button>
        <button class="btn btn-copy" id="copyBtn" disabled>Copy to Clipboard</button>
        <button class="btn btn-status" id="statusBtn">Check Status</button>
        <button class="btn btn-status" id="simulateBtn">Simulate Transcription</button>
        <button class="btn btn-status" id="systemInfoBtn">System Info</button>
        <button class="btn btn-status" id="audioCommandsBtn">Check Audio Commands</button>
        <button class="btn btn-status" id="exportLogsBtn">Export Logs</button>
        <button class="btn btn-status" id="clearLogsBtn">Clear Logs</button>
        <button class="btn btn-status" id="testApiBtn">Test API</button>
      </div>
      
      <div class="debug-section">
        <div class="debug-title">Debug Logs</div>
        <div id="debugLogs"></div>
      </div>
    </div>
    
    <script type="module">
      // Debug logging function
      function log(message, type = 'info') {
        const timestamp = new Date().toLocaleTimeString();
        const logElement = document.createElement('div');
        logElement.className = `debug-log debug-${type}`;
        logElement.innerHTML = `<strong>[${timestamp}]</strong> ${message}`;
        
        const debugLogs = document.getElementById('debugLogs');
        debugLogs.appendChild(logElement);
        debugLogs.scrollTop = debugLogs.scrollHeight;
        
        console.log(`[${type.toUpperCase()}] ${message}`);
      }
      
      // UI elements
      const statusEl = document.getElementById('status');
      const startBtn = document.getElementById('startBtn');
      const stopBtn = document.getElementById('stopBtn');
      const playBtn = document.getElementById('playBtn');
      const convertBtn = document.getElementById('convertBtn');
      const sendBtn = document.getElementById('sendBtn');
      const copyBtn = document.getElementById('copyBtn');
      const statusBtn = document.getElementById('statusBtn');
      const simulateBtn = document.getElementById('simulateBtn');
      const systemInfoBtn = document.getElementById('systemInfoBtn');
      const audioCommandsBtn = document.getElementById('audioCommandsBtn');
      const exportLogsBtn = document.getElementById('exportLogsBtn');
      const clearLogsBtn = document.getElementById('clearLogsBtn');
      const recordingIndicator = document.getElementById('recordingIndicator');
      const audioBars = document.getElementById('audioBars');
      const body = document.body;
      
      // Recording state
      let isRecording = false;
      let base64Data = null;
      let mimeType = 'audio/wav';
      let transcribedText = null;
      let audioData = null;
      let animationId = null;
      
      // Initialize
      log('Debug microphone test initialized', 'info');
      
      // Log initial system state
      log('=== INITIAL SYSTEM STATE ===', 'info');
      log(`User Agent: ${navigator.userAgent}`, 'info');
      log(`Platform: ${navigator.platform}`, 'info');
      log(`MediaDevices API: ${!!navigator.mediaDevices}`, 'info');
      log(`MediaRecorder API: ${typeof MediaRecorder !== 'undefined'}`, 'info');
      log(`AudioContext API: ${typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined'}`, 'info');
      log(`Permissions API: ${!!navigator.permissions}`, 'info');
      log(`Clipboard API: ${!!navigator.clipboard}`, 'info');
      log(`Window Size: ${window.innerWidth}x${window.innerHeight}`, 'info');
      log(`Location: ${window.location.href}`, 'info');
      
      // Test if preload script loaded
      setTimeout(() => {
        log('=== PRELOAD SCRIPT TEST ===', 'info');
        log(`window.audioRecording available: ${typeof window.audioRecording}`, 'info');
        if (window.audioRecording) {
          log(`audioRecording methods: ${Object.keys(window.audioRecording).join(', ')}`, 'info');
        }
      }, 1000);
      
      // Collect system information
      async function collectSystemInfo() {
        const info = {
          timestamp: new Date().toISOString(),
          userAgent: navigator.userAgent,
          platform: navigator.platform,
          language: navigator.language,
          cookieEnabled: navigator.cookieEnabled,
          onLine: navigator.onLine,
          mediaDevices: {
            available: !!navigator.mediaDevices,
            getUserMedia: !!navigator.mediaDevices?.getUserMedia,
            enumerateDevices: !!navigator.mediaDevices?.enumerateDevices
          },
          mediaRecorder: {
            available: typeof MediaRecorder !== 'undefined',
            supportedTypes: []
          },
          audioContext: {
            available: typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined'
          },
          permissions: {
            available: !!navigator.permissions,
            query: !!navigator.permissions?.query
          },
          clipboard: {
            available: !!navigator.clipboard,
            writeText: !!navigator.clipboard?.writeText
          },
          window: {
            innerWidth: window.innerWidth,
            innerHeight: window.innerHeight,
            devicePixelRatio: window.devicePixelRatio
          },
          location: {
            href: window.location.href,
            protocol: window.location.protocol,
            hostname: window.location.hostname,
            pathname: window.location.pathname
          }
        };

        // Check MediaRecorder supported types
        if (info.mediaRecorder.available) {
          const testTypes = [
            'audio/webm;codecs=opus',
            'audio/webm',
            'audio/mp4',
            'audio/ogg;codecs=opus',
            'audio/wav'
          ];
          info.mediaRecorder.supportedTypes = testTypes.filter(type => MediaRecorder.isTypeSupported(type));
        }

        return info;
      }

      // Check if audioRecording API is available
      log('Checking for audioRecording API...', 'info');
      log(`window.audioRecording: ${typeof window.audioRecording}`, 'info');
      
      if (window.audioRecording) {
        log('audioRecording API is available', 'info');
        log(`Available methods: ${Object.keys(window.audioRecording).join(', ')}`, 'info');
        
        // Test the API with a simple call
        try {
          const testResult = await window.audioRecording.getAvailableCommands();
          log(`Test call result: ${JSON.stringify(testResult)}`, 'info');
          
          if (testResult.success) {
            log('Available audio commands:', 'info');
            Object.entries(testResult.commands).forEach(([cmd, available]) => {
              log(`${cmd}: ${available ? '✓' : '✗'}`, 'info');
            });
          } else {
            log(`Failed to get available commands: ${testResult.error}`, 'error');
          }
        } catch (error) {
          log(`Error testing audioRecording API: ${error.message}`, 'error');
          log(`Error stack: ${error.stack}`, 'error');
        }
      } else {
        log('audioRecording API is NOT available - preload script may not have loaded', 'error');
        log('Available window objects:', 'info');
        Object.keys(window).forEach(key => {
          if (key.includes('audio') || key.includes('recording') || key.includes('recorder')) {
            log(`Found: window.${key}`, 'info');
          }
        });
        
        // Create a fallback API that logs errors
        window.audioRecording = {
          startRecording: async (options) => {
            log('Fallback: startRecording called', 'warn');
            return { success: false, error: 'Preload script not working' };
          },
          stopRecording: async () => {
            log('Fallback: stopRecording called', 'warn');
            return { success: false, error: 'Preload script not working' };
          },
          getRecordingState: async () => {
            log('Fallback: getRecordingState called', 'warn');
            return { success: false, error: 'Preload script not working' };
          },
          getAvailableCommands: async () => {
            log('Fallback: getAvailableCommands called', 'warn');
            return { success: false, error: 'Preload script not working' };
          }
        };
      }
      
      async function startRecording() {
        try {
          log('Starting native audio recording...', 'info');
          statusEl.textContent = 'Starting native recording...';
          
          // Check if native audio recording API is available
          if (!window.audioRecording) {
            log('Native audio recording API not available', 'error');
            statusEl.textContent = 'Native audio recording API not available';
            return;
          }
          
          // Reset state
          base64Data = null;
          transcribedText = null;
          audioData = null;
          
          // Start native recording
          const result = await window.audioRecording.startRecording({
            sampleRate: 44100,
            channels: 1,
            format: 'wav'
          });
          
          if (result.success) {
            log('Native audio recording started successfully', 'info');
            isRecording = true;
            updateUI();
            startAudioVisualization();
            statusEl.textContent = 'Recording... Please speak...';
          } else {
            log(`Failed to start native recording: ${result.error}`, 'error');
            statusEl.textContent = `Failed to start recording: ${result.error}`;
          }
          
        } catch (err) {
          log(`Failed to start recording: ${err.message}`, 'error');
          statusEl.textContent = 'Recording failed';
        }
      }
      
      async function stopRecording() {
        log('Stopping native audio recording...', 'info');
        
        if (!window.audioRecording) {
          log('Native audio recording API not available', 'error');
          statusEl.textContent = 'Native audio recording API not available';
          return;
        }
        
        try {
          const result = await window.audioRecording.stopRecording();
          
          if (result.success) {
            log('Native audio recording stopped successfully', 'info');
            audioData = result.result;
            base64Data = result.result.formats.base64;
            log(`Audio data received: ${result.result.fileSize} bytes`, 'info');
            statusEl.textContent = 'Recording stopped - audio data available';
          } else {
            log(`Failed to stop native recording: ${result.error}`, 'error');
            statusEl.textContent = `Failed to stop recording: ${result.error}`;
          }
        } catch (error) {
          log(`Error stopping recording: ${error.message}`, 'error');
          statusEl.textContent = 'Error stopping recording';
        }
        
        isRecording = false;
        updateUI();
        stopAudioVisualization();
      }
      
      function playRecording() {
        log(`Play recording called - audioData: ${audioData ? 'available' : 'none'}`, 'info');
        
        if (!audioData || !audioData.formats || !audioData.formats.base64) {
          log('No audio data available to play', 'warn');
          statusEl.textContent = 'No audio data available to play';
          return;
        }
        
        try {
          // Convert base64 to blob
          const binaryString = atob(audioData.formats.base64);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          
          const blob = new Blob([bytes], { type: 'audio/wav' });
          log(`Created blob for playback: ${blob.size} bytes`, 'info');
          const url = URL.createObjectURL(blob);
          const audio = new Audio(url);
          
          audio.onplay = () => {
            log('Playing recording...', 'info');
            statusEl.textContent = 'Playing recording...';
          };
          audio.onended = () => {
            log('Playback finished', 'info');
            statusEl.textContent = 'Playback finished';
            URL.revokeObjectURL(url);
          };
          audio.onerror = (e) => {
            log(`Playback error: ${e.message}`, 'error');
            statusEl.textContent = 'Playback error';
          };
          
          audio.play().catch(error => {
            log(`Audio play failed: ${error.message}`, 'error');
            statusEl.textContent = 'Failed to play audio';
          });
        } catch (error) {
          log(`Failed to play recording: ${error.message}`, 'error');
          statusEl.textContent = 'Failed to play recording';
        }
      }
      
      async function convertToBase64() {
        log('Converting audio to base64...', 'info');
        
        if (!audioData || !audioData.formats || !audioData.formats.base64) {
          log('No audio data available to convert', 'warn');
          statusEl.textContent = 'No audio data available to convert';
          return;
        }
        
        try {
          statusEl.textContent = 'Converting to base64...';
          base64Data = audioData.formats.base64;
          
          log(`Base64 conversion successful: ${base64Data.length} characters`, 'info');
          statusEl.textContent = 'Converted to base64 successfully';
          
          // Enable send button after conversion
          updateUI();
        } catch (error) {
          log(`Failed to convert to base64: ${error.message}`, 'error');
          statusEl.textContent = 'Failed to convert to base64';
        }
      }
      
      function sendToGemini() {
        log('Sending audio to Gemini...', 'info');
        
        if (!base64Data) {
          log('No base64 data available', 'warn');
          statusEl.textContent = 'Please convert to base64 first';
          return;
        }
        
        // Check if recorderAPI is available for sending to Gemini
        if (!window.recorderAPI) {
          log('recorderAPI is not available for Gemini transcription', 'error');
          statusEl.textContent = 'recorderAPI not available for transcription';
          return;
        }
        
        if (!window.recorderAPI.sendAudio) {
          log('sendAudio method is not available', 'error');
          statusEl.textContent = 'sendAudio method not available';
          return;
        }
        
        try {
          statusEl.textContent = 'Sending to Gemini...';
          log(`Sending audio: ${base64Data.length} chars, mimeType: ${mimeType}`, 'info');
          window.recorderAPI.sendAudio(base64Data, mimeType);
          log('Audio sent to Gemini for transcription', 'info');
          
          // Set a timeout to handle cases where IPC response doesn't arrive
          setTimeout(() => {
            if (statusEl.textContent === 'Sending to Gemini...') {
              log('No response from Gemini after 10 seconds, checking status...', 'warn');
              statusEl.textContent = 'No response from Gemini - check logs';
            }
          }, 10000);
        } catch (error) {
          log(`Failed to send to Gemini: ${error.message}`, 'error');
          statusEl.textContent = 'Failed to send to Gemini';
        }
      }
      
      function copyToClipboard() {
        log('Copying to clipboard...', 'info');
        
        if (!transcribedText) {
          log('No transcribed text available', 'warn');
          statusEl.textContent = 'No text to copy';
          return;
        }
        
        try {
          navigator.clipboard.writeText(transcribedText).then(() => {
            log(`Copied to clipboard: "${transcribedText}"`, 'info');
            statusEl.textContent = 'Copied to clipboard!';
          }).catch(error => {
            log(`Failed to copy to clipboard: ${error.message}`, 'error');
            statusEl.textContent = 'Failed to copy to clipboard';
          });
        } catch (error) {
          log(`Failed to copy to clipboard: ${error.message}`, 'error');
          statusEl.textContent = 'Failed to copy to clipboard';
        }
      }
      
      function checkStatus() {
        log('Checking current status...', 'info');
        log(`Current status: ${statusEl.textContent}`, 'info');
        log(`Transcribed text: ${transcribedText || 'None'}`, 'info');
        log(`Base64 data: ${base64Data ? base64Data.length + ' chars' : 'None'}`, 'info');
        log(`Audio data: ${audioData ? 'Available' : 'None'}`, 'info');
        log(`Is recording: ${isRecording}`, 'info');
        
        if (statusEl.textContent === 'Sending to Gemini...') {
          log('Still waiting for Gemini response...', 'warn');
          statusEl.textContent = 'Still waiting for Gemini response...';
        }
      }
      
      async function showSystemInfo() {
        log('Collecting system information...', 'info');
        try {
          const systemInfo = await collectSystemInfo();
          log('=== SYSTEM INFORMATION ===', 'info');
          log(`Timestamp: ${systemInfo.timestamp}`, 'info');
          log(`User Agent: ${systemInfo.userAgent}`, 'info');
          log(`Platform: ${systemInfo.platform}`, 'info');
          log(`Language: ${systemInfo.language}`, 'info');
          log(`Online: ${systemInfo.onLine}`, 'info');
          log(`Cookie Enabled: ${systemInfo.cookieEnabled}`, 'info');
          
          log('=== MEDIA DEVICES ===', 'info');
          log(`MediaDevices API: ${systemInfo.mediaDevices.available}`, 'info');
          log(`getUserMedia: ${systemInfo.mediaDevices.getUserMedia}`, 'info');
          log(`enumerateDevices: ${systemInfo.mediaDevices.enumerateDevices}`, 'info');
          
          log('=== MEDIA RECORDER ===', 'info');
          log(`MediaRecorder API: ${systemInfo.mediaRecorder.available}`, 'info');
          log(`Supported Types: ${systemInfo.mediaRecorder.supportedTypes.join(', ')}`, 'info');
          
          log('=== AUDIO CONTEXT ===', 'info');
          log(`AudioContext API: ${systemInfo.audioContext.available}`, 'info');
          
          log('=== PERMISSIONS ===', 'info');
          log(`Permissions API: ${systemInfo.permissions.available}`, 'info');
          log(`Query Method: ${systemInfo.permissions.query}`, 'info');
          
          log('=== CLIPBOARD ===', 'info');
          log(`Clipboard API: ${systemInfo.clipboard.available}`, 'info');
          log(`WriteText Method: ${systemInfo.clipboard.writeText}`, 'info');
          
          log('=== WINDOW ===', 'info');
          log(`Inner Size: ${systemInfo.window.innerWidth}x${systemInfo.window.innerHeight}`, 'info');
          log(`Device Pixel Ratio: ${systemInfo.window.devicePixelRatio}`, 'info');
          
          log('=== LOCATION ===', 'info');
          log(`Protocol: ${systemInfo.location.protocol}`, 'info');
          log(`Hostname: ${systemInfo.location.hostname}`, 'info');
          log(`Pathname: ${systemInfo.location.pathname}`, 'info');
          
          // Try to enumerate audio devices
          if (systemInfo.mediaDevices.enumerateDevices) {
            try {
              const devices = await navigator.mediaDevices.enumerateDevices();
              const audioDevices = devices.filter(device => device.kind === 'audioinput');
              log(`=== AUDIO DEVICES (${audioDevices.length}) ===`, 'info');
              audioDevices.forEach((device, index) => {
                log(`Device ${index + 1}: ${device.label || 'Unknown'} (${device.deviceId})`, 'info');
              });
            } catch (error) {
              log(`Failed to enumerate devices: ${error.message}`, 'error');
            }
          }
          
          // Check microphone permission status
          if (systemInfo.permissions.query) {
            try {
              const permission = await navigator.permissions.query({ name: 'microphone' });
              log(`=== MICROPHONE PERMISSION ===`, 'info');
              log(`Status: ${permission.state}`, 'info');
              log(`Granted: ${permission.state === 'granted'}`, 'info');
            } catch (error) {
              log(`Failed to check microphone permission: ${error.message}`, 'error');
            }
          }
          
          statusEl.textContent = 'System information collected - check logs';
        } catch (error) {
          log(`Failed to collect system info: ${error.message}`, 'error');
          statusEl.textContent = 'Failed to collect system info';
        }
      }

      async function checkAudioCommands() {
        log('Checking audio recording commands...', 'info');
        try {
          // Check if audioRecording API is available
          if (window.audioRecording) {
            log('=== AUDIO RECORDING API ===', 'info');
            log(`Audio Recording API: Available`, 'info');
            log(`Available methods: ${Object.keys(window.audioRecording).join(', ')}`, 'info');
            
            // Check available commands
            if (window.audioRecording.getAvailableCommands) {
              const result = await window.audioRecording.getAvailableCommands();
              if (result.success) {
                log('=== AVAILABLE AUDIO COMMANDS ===', 'info');
                Object.entries(result.commands).forEach(([cmd, available]) => {
                  log(`${cmd}: ${available ? '✓ Available' : '✗ Not Available'}`, 'info');
                });
              } else {
                log(`Failed to get available commands: ${result.error}`, 'error');
              }
            }
            
            // Check recording state
            if (window.audioRecording.getRecordingState) {
              const result = await window.audioRecording.getRecordingState();
              if (result.success) {
                log('=== RECORDING STATE ===', 'info');
                log(`Is Recording: ${result.state.isRecording}`, 'info');
                log(`Start Time: ${result.state.startTime}`, 'info');
                log(`Duration: ${result.state.duration}ms`, 'info');
                log(`Audio Data: ${result.state.audioData ? 'Available' : 'None'}`, 'info');
                log(`Options: ${JSON.stringify(result.state.options)}`, 'info');
              } else {
                log(`Failed to get recording state: ${result.error}`, 'error');
              }
            }
          } else {
            log('Audio Recording API: Not Available', 'warn');
          }
          
          statusEl.textContent = 'Audio commands checked - check logs';
        } catch (error) {
          log(`Failed to check audio commands: ${error.message}`, 'error');
          statusEl.textContent = 'Failed to check audio commands';
        }
      }

      function exportLogs() {
        log('Exporting logs...', 'info');
        try {
          const debugLogs = document.getElementById('debugLogs');
          const logs = Array.from(debugLogs.children).map(logEl => {
            const text = logEl.textContent || logEl.innerText;
            return text.replace(/^\s*\[\d{1,2}:\d{2}:\d{2}\s*(?:AM|PM)?\]\s*/, '');
          }).join('\n');
          
          const systemInfo = {
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            logs: logs
          };
          
          const blob = new Blob([JSON.stringify(systemInfo, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `speech-paste-debug-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          
          log('Logs exported successfully', 'info');
          statusEl.textContent = 'Logs exported successfully';
        } catch (error) {
          log(`Failed to export logs: ${error.message}`, 'error');
          statusEl.textContent = 'Failed to export logs';
        }
      }

      function clearLogs() {
        log('Clearing logs...', 'info');
        const debugLogs = document.getElementById('debugLogs');
        debugLogs.innerHTML = '';
        log('Logs cleared', 'info');
        statusEl.textContent = 'Logs cleared';
      }

      function simulateTranscription() {
        log('Simulating transcription completion...', 'info');
        // Use the actual transcription result from the logs
        transcribedText = 'base system';
        log(`Simulated transcription: "${transcribedText}"`, 'info');
        statusEl.textContent = 'Simulated transcription completed!';
        updateUI();
      }
      
      function updateUI() {
        log(`updateUI called - isRecording: ${isRecording}, audioData: ${audioData ? 'available' : 'none'}`, 'info');
        
        if (isRecording) {
          body.classList.add('recording');
          recordingIndicator.style.display = 'inline-block';
          startBtn.disabled = true;
          stopBtn.disabled = false;
          playBtn.disabled = true;
        } else {
          body.classList.remove('recording');
          recordingIndicator.style.display = 'none';
          startBtn.disabled = false;
          stopBtn.disabled = true;
          playBtn.disabled = !audioData;
          convertBtn.disabled = !audioData;
          sendBtn.disabled = !base64Data;
          copyBtn.disabled = !transcribedText;
        }
        
        log(`Play button disabled: ${playBtn.disabled}`, 'info');
      }
      
      function startAudioVisualization() {
        const bars = audioBars.querySelectorAll('.audio-bar');
        
        function updateVisualization() {
          if (!isRecording) return;
          
          // Simulate audio visualization for native recording
          bars.forEach((bar, index) => {
            const value = Math.random() * 255;
            const height = Math.max(8, (value / 255) * 40);
            bar.style.height = height + 'px';
          });
          
          animationId = requestAnimationFrame(updateVisualization);
        }
        
        updateVisualization();
      }
      
      function stopAudioVisualization() {
        if (animationId) {
          cancelAnimationFrame(animationId);
          animationId = null;
        }
        const bars = audioBars.querySelectorAll('.audio-bar');
        bars.forEach(bar => {
          bar.style.height = '8px';
        });
      }
      
      // Event listeners
      startBtn.addEventListener('click', startRecording);
      stopBtn.addEventListener('click', () => stopRecording());
      playBtn.addEventListener('click', playRecording);
      convertBtn.addEventListener('click', convertToBase64);
      sendBtn.addEventListener('click', sendToGemini);
      copyBtn.addEventListener('click', copyToClipboard);
      statusBtn.addEventListener('click', checkStatus);
      simulateBtn.addEventListener('click', simulateTranscription);
      systemInfoBtn.addEventListener('click', showSystemInfo);
      audioCommandsBtn.addEventListener('click', checkAudioCommands);
      exportLogsBtn.addEventListener('click', exportLogs);
      clearLogsBtn.addEventListener('click', clearLogs);
      
      // Audio recording event listeners
      log('Setting up audio recording event listeners...', 'info');
      
      if (window.audioRecording && window.audioRecording.on) {
        window.audioRecording.on.recordingStarted(() => {
          log('Native audio recording started', 'info');
          isRecording = true;
          updateUI();
        });
        
        window.audioRecording.on.recordingStopped(() => {
          log('Native audio recording stopped', 'info');
          isRecording = false;
          updateUI();
        });
        
        window.audioRecording.on.audioDataReady((data) => {
          log('Audio data ready event received', 'info');
          audioData = data;
          updateUI();
        });
        
        window.audioRecording.on.recordingError((error) => {
          log(`Native audio recording error: ${error.message}`, 'error');
          statusEl.textContent = `Recording error: ${error.message}`;
        });
      }
      
      // IPC handlers for Gemini transcription (if recorderAPI is available)
      if (window.recorderAPI) {
        log('Setting up IPC handlers for transcription...', 'info');
        
        window.recorderAPI.onProcessing(() => {
          log('Processing state received from main process', 'info');
          statusEl.textContent = 'Processing audio...';
        });
        
        window.recorderAPI.onTranscribed((event, text) => {
          log('Received transcription result from main process', 'info');
          transcribedText = text;
          log(`Transcription completed: "${text}"`, 'info');
          statusEl.textContent = 'Transcription completed!';
          // Enable copy button after transcription
          updateUI();
        });
        
        window.recorderAPI.onError((message) => {
          log(`Error from main process: ${message}`, 'error');
          statusEl.textContent = `Error: ${message}`;
        });
      }
      
      log('Event listeners set up successfully', 'info');
      
      // Initialize UI
      updateUI();
      log('UI initialized', 'info');
    </script>
  </body>
</html>
